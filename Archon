package ProtoPlayer;

import java.util.ArrayList;
import java.util.Random;

import battlecode.common.*;

public class Utility{

	static RobotController rc = RobotPlayer.rc;
	static int count = 1;
	public static boolean dig = false;
	static int[] possibleDirection = new int[]{0,1,-1,2,-2,3,-3,4};
	static ArrayList<MapLocation> pastLocations = new ArrayList<MapLocation>();
	static MapLocation archonLocation = rc.getLocation();
	static Random rnd;
	static ArrayList<MapLocation> stayed = new ArrayList<MapLocation>();

	public static void advance(Direction ahead, int type) throws GameActionException {

		int callType = type;

		stayed.add(rc.getLocation());

		Direction viable = null;

		for(int i:possibleDirection){
			Direction candidateDirection = Direction.values()[(ahead.ordinal()+i+8)%8];
			MapLocation candidateLocation = rc.getLocation().add(candidateDirection);
			if(rc.canMove(candidateDirection)&& !pastLocations.contains(candidateLocation)){
				viable = candidateDirection;
				break;
			}
		}




		if(callType == 1 && viable != null){
			pastLocations.add(rc.getLocation());
			if(pastLocations.size()>10)
				pastLocations.remove(0);
			rc.move(viable);
		}
		else if(callType == 2 &&  viable != null){
			pastLocations.add(rc.getLocation());
			if(pastLocations.size()>5)
				pastLocations.remove(0);
			rc.move(viable);
		}
		else if(viable == null){  
			dig = true;     //viable is null
		}

		int checkdig = 0;
		for(MapLocation i: stayed){
			if(stayed.get(0) == i){
				checkdig++;
			}
		}

		if(checkdig > 4 && rc.getType().canClearRubble() && rc.isCoreReady()){
			rc.clearRubble(ahead);
		}

		if(dig == true && viable != null){
			if(rc.canMove(viable)){ //can't check moving in null direction.
				if(rc.isCoreReady())
					rc.move(viable);
			}
			else if(rc.senseRubble(rc.getLocation().add(viable))> GameConstants.RUBBLE_OBSTRUCTION_THRESH && rc.isCoreReady()){
				rc.clearRubble(viable);
			}
		}

	}

	public static Direction isClear(Direction ahead){

		Direction viable = null;

		for(int i:possibleDirection){
			Direction candidateDirection = Direction.values()[(ahead.ordinal()+i+8)%8];
			MapLocation candidateLocation = rc.getLocation().add(candidateDirection);
			if(rc.canMove(candidateDirection)&& !pastLocations.contains(candidateLocation)){
				viable = candidateDirection;
				break;
			}
		}
		return viable;
	}

	public static void attack(int moveType) throws GameActionException{


		RobotInfo[] enemies = rc.senseHostileRobots(rc.getLocation(), rc.getType().attackRadiusSquared);


		if(rc.isCoreReady() && enemies.length > 0 && rc.getType() != RobotType.TURRET){
			if(rc.isWeaponReady()){
				rc.attackLocation(enemies[0].location);
			}
		}
		else if (rc.isCoreReady() && enemies.length > 0 && rc.getType() == RobotType.TURRET){
			if(rc.isWeaponReady() && rc.getLocation().distanceSquaredTo(enemies[0].location) > 5){
				rc.attackLocation(enemies[0].location);
			}
		}
		else if(rc.getType().canMove()){

			MapLocation arc = archonLocation.add(Direction.NORTH, 4);
			if(enemies.length == 0 && rc.isCoreReady()){
				advance(rc.getLocation().directionTo(arc),moveType);

			}
		}	
	}


	public static void circle(int radiusC) throws GameActionException{

		if(rc.getLocation().distanceSquaredTo(archonLocation)>radiusC && rc.isCoreReady()){
			advance(rc.getLocation().directionTo(archonLocation),1);
		}
		else if(rc.getLocation().distanceSquaredTo(archonLocation)<8 && rc.isCoreReady()){
			advance(rc.getLocation().directionTo(archonLocation).opposite(),1);
		}
		else{
			if(rc.isCoreReady() && rc.getRoundNum()%2 == 0){
				advance(rc.getLocation().directionTo(archonLocation).rotateRight().rotateRight(),1);
			}
			else if(rc.isCoreReady() && rc.getRoundNum()%2 != 0){
				advance(rc.getLocation().directionTo(archonLocation).rotateLeft().rotateLeft(),1);
			}
		}

	}



	public static void sendingInstructions() throws GameActionException {

		rc.broadcastMessageSignal(rc.getTeam().ordinal(), 0, 5000);
	}

	public static MapLocation followingInstructions() {

		Signal[] incomingMessages = rc.emptySignalQueue();
		if(incomingMessages.length==0)
			return null;
		Signal currentMessage = null;
		for(int messageIndex = 0; messageIndex<incomingMessages.length;messageIndex++)
		{
			currentMessage = incomingMessages[messageIndex];
			if(currentMessage!=null){
				if(rc.getTeam().ordinal()==currentMessage.getTeam().ordinal())
					break;
			}
		}
		if(currentMessage==null)
			return null;
		archonLocation = currentMessage.getLocation();
		return archonLocation;
	}

	public static Direction randomDirection() {
		rnd = new Random(rc.getID());
		return Direction.values()[(int)(rnd.nextDouble()*8)];
	}

}
